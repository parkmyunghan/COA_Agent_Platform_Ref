# OWL-RL 추론 중복 실행 분석

## 문제 현상

시스템 시작 시 OWL-RL 추론이 두 번 실행되며, 두 번째 추론에서 추가 트리플이 생성됩니다:

### 첫 번째 추론
- **원본**: 6,613 triples
- **RDFS 추론 후**: 9,359 triples (+2,746)
- **OWL-RL 추론 후**: 12,834 triples (+6,221 총 증가)

### 두 번째 추론
- **원본**: 12,834 triples (첫 번째 추론 결과)
- **RDFS 추론 후**: 13,204 triples (+370)
- **OWL-RL 추론 후**: 13,375 triples (+541 총 증가)

## 원인 분석

### 1. 이론적 배경

`owlrl`의 `DeductiveClosure.expand()` 메서드는 **idempotent**해야 합니다. 즉, 같은 그래프에 두 번 실행하면 두 번째 실행에서는 새로운 트리플이 추가되지 않아야 합니다.

### 2. 실제 발생 원인

두 번째 추론에서 추가 트리플이 생성되는 이유:

#### 가능성 1: 첫 번째 추론이 완전하지 않음
- 첫 번째 추론이 완료되기 전에 중단되었을 수 있음
- 일부 추론 규칙이 적용되지 않았을 수 있음
- 하지만 로그상 첫 번째 추론은 정상 완료되었음

#### 가능성 2: RDFS 추론의 비결정적 동작
- 첫 번째 추론: RDFS 추론 후 9,359 triples
- 두 번째 추론: RDFS 추론 후 13,204 triples (12,834 + 370)
- 두 번째 추론에서 RDFS 추론이 추가 트리플(+370)을 생성함

이는 첫 번째 추론에서 RDFS 추론이 완전히 적용되지 않았거나, 두 번째 추론 시 그래프 상태가 달랐을 가능성을 시사합니다.

#### 가능성 3: 그래프 상태 변경 (검증 완료)
- 첫 번째 추론과 두 번째 추론 사이에 그래프에 트리플이 추가되었을 수 있음
- 하지만 로그상 두 번째 추론의 "원본"은 첫 번째 추론 결과(12,834)와 동일함
- **검증 결과**: LLM/RAG/규칙 파일 로드 과정에서 그래프에 트리플을 추가하는 코드는 없음
  - `LLMManager`, `RAGManager`, `RuleEngine`은 그래프를 읽기 전용으로만 사용
  - 첫 번째 추론 후 `self.ontology_manager.graph = inferred_graph`로 그래프가 업데이트되지만, 두 번째 추론 시 동일한 그래프를 사용
  - **결론**: LLM/RAG/규칙 파일 로드로 인한 그래프 변경은 없음

### 3. 실제 원인 (가장 가능성 높음)

**첫 번째 추론이 완전하지 않았을 가능성**:
- 첫 번째 추론에서 RDFS 추론 후 9,359 triples였지만, OWL-RL 추론 후 12,834 triples로 증가
- 두 번째 추론에서 RDFS 추론을 다시 실행하면 12,834 → 13,204로 증가 (+370)
- 이는 첫 번째 추론에서 RDFS 추론이 완전히 적용되지 않았거나, OWL-RL 추론 과정에서 일부 RDFS 규칙이 누락되었을 수 있음
- **가능한 이유**: RDFS 추론과 OWL-RL 추론의 상호작용 또는 추론 규칙 적용 순서에 따른 것

## 해결 방안

### 방안 1: 중복 추론 방지 (현재 구현)
- `_inference_performed` 플래그를 사용하여 중복 추론 방지
- 첫 번째 추론 후 플래그 설정
- 두 번째 추론 시 플래그 확인하여 스킵

**장점**:
- 성능 향상 (추론 시간 절약)
- 중복 작업 방지

**단점**:
- 첫 번째 추론이 완전하지 않은 경우, 일부 트리플이 누락될 수 있음

### 방안 2: 추론 완전성 보장
- 추론 전후 트리플 수 비교
- 추론이 완전히 완료되었는지 확인
- 완전하지 않은 경우 재시도

**장점**:
- 추론 완전성 보장

**단점**:
- 구현 복잡도 증가
- 성능 오버헤드

### 방안 3: 하이브리드 접근 (권장)
- 첫 번째 추론 실행
- 추론 완료 후 트리플 수 확인
- 예상 범위 내인지 검증
- 범위를 벗어나면 재추론 또는 경고

## 현재 구현 상태

현재는 **방안 1 (중복 추론 방지)**을 구현했습니다:
- `EnhancedOntologyManager`에서 첫 번째 추론 실행 시 플래그 설정
- `CorePipeline`에서 플래그 확인하여 중복 추론 스킵

## 예상 결과

중복 추론을 스킵하면:
- **트리플 수**: 12,834에서 멈춤 (첫 번째 추론 결과)
- **성능**: 추론 시간 약 6-7초 절약
- **완전성**: 첫 번째 추론이 완전했다면 문제 없음

## 검증 방법

1. 시스템 재시작 후 로그 확인
2. "이미 추론이 실행되었습니다. 중복 추론을 건너뜁니다." 메시지 확인
3. 최종 트리플 수가 12,834인지 확인
4. 추론 결과가 정상적으로 작동하는지 확인

## 추론 여부 판단 기준 검토

### 현재 기준 (개선 완료)
- **기존**: `current_triples > 10000` (10,000개 이상) - 하드코딩된 절대값
- **1차 개선**: `current_triples >= 8000` (원본 대비 약 1.2배 이상) - 여전히 하드코딩
- **최종 개선**: `current_triples >= _original_graph_size * 1.3` (원본 대비 1.3배 이상) - **동적 비율 기반**

### 기준 설정 근거
- **원본 그래프(instances.ttl)**: 동적으로 측정 (예: 6,613 triples)
- **추론된 그래프**: 일반적으로 원본의 약 2배 (예: 12,834 triples)
- **안전 마진**: 원본 대비 1.3배 이상이면 추론된 것으로 간주

### 개선 이유
1. **절대값 기준의 문제점**:
   - 10,000개 또는 8,000개 기준은 현재 데이터셋에 맞춘 임의의 값
   - 데이터셋 크기가 변경되면 기준값도 변경 필요
   - 원본 데이터가 작아지거나 커지면 기준이 무의미해짐

2. **동적 비율 기반 기준의 장점**:
   - 원본 그래프 크기를 `instances.ttl` 로드 시 자동으로 추적
   - 원본 대비 비율로 판단하므로 데이터셋 크기와 무관
   - 추론된 그래프는 일반적으로 원본의 약 2배이므로, 1.3배 이상이면 추론된 것으로 간주
   - 원본 데이터가 변경되어도 자동으로 적응

3. **실제 적용**:
   - 원본: 6,613 triples (동적 측정)
   - 추론 후: 12,834 triples (약 1.94배)
   - 기준: 원본 대비 1.3배 이상
   - 결과: 추론된 그래프(12,834)는 기준(6,613 * 1.3 = 8,597)을 충족하므로 추론 스킵

### 구현 방법
1. `EnhancedOntologyManager.__init__`에 `_original_graph_size` 속성 추가
2. `try_load_existing_graph()`에서 `instances.ttl` 로드 직후 원본 크기 저장
3. 추론 여부 판단 시 `current_triples >= _original_graph_size * 1.3` 비율 기반 판단

### 향후 개선 방향
- `instances_reasoned.ttl` 파일 존재 여부를 우선적으로 확인하여 추론 여부 판단 (가장 확실한 방법)
- 비율 기준값(1.3)을 설정 파일에서 조정 가능하도록 개선

## 추가 개선 사항

만약 첫 번째 추론이 완전하지 않은 것으로 확인되면:
1. 추론 완전성 검증 로직 추가
2. 추론 실패 시 재시도 메커니즘 구현
3. 추론 통계를 더 상세히 기록하여 분석
4. `instances_reasoned.ttl` 파일 존재 여부를 우선적으로 확인하여 추론 여부 판단
