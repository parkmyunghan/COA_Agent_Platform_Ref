# 지식그래프 (RDF/TTL)

## 1. 개요

- **역할**: 구조화된 지식 저장소 (RDF 형식)
- **위치**: Data Layer
- **형식**: RDF (Resource Description Framework), TTL (Turtle)
- **다이어그램 표시**: "지식그래프 (RDF/TTL)"

지식그래프는 온톨로지 변환기가 생성한 RDF 형식의 그래프 데이터입니다. 엔티티 간의 관계를 삼중항(Triple) 형태로 저장하여 추론과 검색을 지원합니다.

---

## 2. 주요 기능

### 2.1 지식 표현
- **삼중항(Triple)**: 주체-서술어-객체 구조
- **엔티티 관계**: 위협, 방책, 자산, 위치 등 간의 관계
- **계층 구조**: 클래스 및 인스턴스 계층

### 2.2 추론 지원
- SPARQL 쿼리를 통한 관계 탐색
- 다단계 관계 체인 발견
- 관련 엔티티 자동 탐색

### 2.3 지속성
- 파일로 저장 (.ttl 형식)
- 로드 및 재사용 가능

---

## 3. 구현 상세

### 3.1 데이터 구조
RDF 그래프는 RDFLib의 `Graph` 객체로 표현됩니다:

```python
from rdflib import Graph, Namespace

graph = Graph()
ns = Namespace("http://defense-ai.kr/ontology#")

# 삼중항 추가 예시
graph.add((ns["THR001"], ns["hasThreat"], ns["침투"]))
graph.add((ns["COA_DEF_001"], ns["countersThreat"], ns["THR001"]))
```

### 3.2 TTL 파일 구조 (재설계)

시스템은 다음 3단계 TTL 파일 구조를 사용합니다:

#### 3.2.1 파일 구성

1. **schema.ttl** (스키마 전용)
   - 클래스, 속성, 관계 정의만 포함
   - 크기: 작음 (약 수백 KB)
   - 생성: `generate_owl_ontology()` 호출 시
   - 사용: 스키마 검증, 온톨로지 편집기

2. **instances.ttl** (인스턴스 전용)
   - 실제 데이터만 포함 (COA, 위협, 자산 등)
   - 크기: 큼 (약 수십 MB)
   - 생성: `generate_instances()` 호출 시
   - 사용: 방책 추천, 관계 체인 탐색, 점수 계산
   - 최적화: 팔란티어 방식에 최적화된 구조

3. **instances_reasoned.ttl** (추론 결과)
   - 의미 추론 결과 저장
   - 우선순위: 최우선 로드
   - 생성: `generate_reasoned_graph()` 메서드 호출 시 (SemanticInference 사용)
   - 사용: 고급 추론 쿼리, 관계 체인 탐색
   - 내용: 기존 instances.ttl + 추론된 관계 (inferred_relation)

#### 3.2.2 로드 우선순위

그래프 로드 시 다음 우선순위로 파일을 찾습니다:

1. `instances_reasoned.ttl` (최우선)
2. `instances.ttl`
3. `schema.ttl`

#### 3.2.3 기존 파일 정리

- 기존 중간 생성물 파일 (`outputs/k_c4i_ontology_owl.ttl`, `outputs/k_c4i_instances_owl.ttl`)은 자동으로 백업 후 삭제됩니다.
- 백업 위치: `outputs/backup/`

### 3.3 저장 형식
- **메모리**: RDFLib Graph 객체
- **파일**: Turtle (.ttl) 형식 (2단계 구조: schema.ttl + instances.ttl)

---

## 4. 데이터 흐름

```
Excel 데이터
    ↓
온톨로지 변환기 (EnhancedOntologyManager)
    ↓
RDF Graph 생성
    ├─→ 메모리 저장 (self.graph)
    └─→ 파일 저장 (2단계 또는 3단계 구조)
        ├─→ schema.ttl (스키마만)
        ├─→ instances.ttl (인스턴스만)
        └─→ instances_reasoned.ttl (인스턴스 + 추론 결과, 선택적)
    ↓
추론 엔진 (SemanticInference)
    ├─→ 의미 기반 관계 추론
    └─→ instances_reasoned.ttl 생성
    ↓
다른 컴포넌트에서 사용
    ├─→ Agent: SPARQL 쿼리
    ├─→ RelationshipChain: 관계 체인 탐색
    └─→ COAScorer: 자원/환경 정보 조회
```

---

## 5. 설정 및 파라미터

### 5.1 저장 경로
- **위치**: `knowledge/ontology/`
- **파일 형식**: `.ttl` (Turtle)

### 5.2 네임스페이스
- **기본**: `http://defense-ai.kr/ontology#`
- **레거시**: `http://coa-agent-platform.org/ontology#` (호환성)

---

## 6. 사용 예시

### 6.1 그래프 로드
```python
from core_pipeline.ontology_manager_enhanced import EnhancedOntologyManager

ontology_manager = EnhancedOntologyManager(config)
graph = ontology_manager.load_graph()
```

### 6.2 SPARQL 쿼리
```python
# 그래프에서 방책 검색
query = """
PREFIX def: <http://defense-ai.kr/ontology#>
SELECT ?coa WHERE {
    ?coa rdf:type def:DefenseCOA .
}
"""
results = graph.query(query)
```

### 6.3 관계 탐색
```python
# 위협과 방책 간의 관계 탐색
from core_pipeline.relationship_chain import RelationshipChain

chain_finder = RelationshipChain(config)
chains = chain_finder.find_relationship_chains(
    graph,
    start_entity="THR001",
    target_type="def:COA"
)
```

---

## 7. 관련 컴포넌트

### 7.1 생성
- **온톨로지 변환기**: Excel 데이터로부터 그래프 생성

### 7.2 사용
- **Agent**: 방책 검색 및 추론
- **RelationshipChain**: 관계 체인 탐색
- **COAScorer**: 자원/환경 정보 조회
- **온톨로지 추론기**: SPARQL 쿼리 실행

---

## 8. 참고 자료

- **코드 위치**: 
  - `core_pipeline/ontology_manager_enhanced.py`
  - `core_pipeline/relationship_chain.py`
- **관련 문서**: 
  - `docs/온톨로지_설계.md`
  - `docs/components/data_layer/02_온톨로지변환기.md`
- **RDF 표준**: https://www.w3.org/RDF/

---

## 9. 중요 사항

### 9.1 삼중항 구조
모든 지식은 (주체, 서술어, 객체) 형태의 삼중항으로 표현됩니다:
- **주체**: 엔티티 URI (예: `def:THR001`)
- **서술어**: 관계명 (예: `def:hasThreat`)
- **객체**: 값 또는 다른 엔티티 (예: `def:침투`)

### 9.2 추론 가능성
RDF 그래프는 SPARQL을 통해 복잡한 추론 쿼리를 실행할 수 있습니다.

---

## 10. 기술 스택 결정: RDFLib vs Fuseki

본 시스템은 온톨로지 관리를 위해 전용 서버인 **Apache Jena Fuseki** 대신 파이썬 라이브러리인 **RDFLib**를 사용합니다. 이 결정의 배경과 차이점은 다음과 같습니다.

### 10.1 비교 포인트

| 비교 항목 | RDFLib (현재 선정) | Apache Jena Fuseki |
| :--- | :--- | :--- |
| **시스템 형태** | 파이썬 라이브러리 (Embedded) | 독립 실행형 SPARQL 서버 |
| **접근 방식** | 애플리케이션 내 직접 메모리 로드 | HTTP/REST 엔드포인트를 통한 통신 |
| **데이터 저장** | 로컬 `.ttl` 파일 | 서버 내 TDB 또는 외부 저장소 |
| **복잡도** | 매우 낮음 (추가 설치/운영 필요 없음) | 중간 (서버 프로세스 관리 필요) |
| **성능 (로컬)** | 고성능 (네트워크 오버헤드 없음) | 약간의 네트워크 대기시간 발생 |

### 10.2 RDFLib 선정 사유

1. **경량성 및 단순성**: 
   - 별도의 서버 프로세스를 유지관리할 필요가 없어 시스템 배포 및 구축이 간편합니다.
   - 단일 에이전트 기반 시스템에서 가장 효율적인 구조입니다.
2. **로컬 오프라인 환경 최적화**: 
   - 외부 네트워크 연동 없이 로컬 파일(`knowledge/ontology/`)만으로 동작하므로 보안 및 폐쇄망 환경에 유리합니다.
3. **Python 생태계 통합**: 
   - `core_pipeline` 내의 분석 로직과 직접 메모리 객체를 공유할 수 있어 데이터 연동이 직관적입니다.
4. **추론 효율성**: 
   - `SemanticInference` 컴포넌트와 함께 사용하여 로컬에서 즉각적인 지식 추론과 결과 저장이 용이합니다.

---

**작성일**: 2025년 12월  
**최종 업데이트**: 2025-12-24  
**버전**: 1.1

