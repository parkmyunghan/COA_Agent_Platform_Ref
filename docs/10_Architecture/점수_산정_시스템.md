# 점수 산정 시스템

## 1. 개요

Defense Intelligent Agent Platform의 방책 추천 시스템은 **팔란티어 모드**를 통해 7가지 핵심 요소를 종합적으로 평가하여 방책의 적합성을 점수화합니다.

---

## 2. 평가 요소 (7가지)

### 2.1 위협 대응 (Threat) ✅

**입력 정보**:
- `threat_level`: 위협 수준 (0.0~1.0)
- `situation_info`에서 직접 추출

**알고리즘**:
```python
# core_pipeline/coa_scorer.py
def _calculate_threat_score(self, context: Dict) -> float:
    threat_level = context.get('threat_level')
    # 0-100 범위를 0-1로 정규화
    if threat_level > 1.0:
        threat_score = threat_level / 100.0
    else:
        threat_score = threat_level
    # 위치 근접도 가중치 적용
    location_proximity = context.get('location_proximity', 1.0)
    if location_proximity != 1.0:
        threat_score = min(1.0, threat_score * (1.0 + (location_proximity - 1.0) * 0.2))
    return min(1.0, max(0.0, threat_score))
```

**구현 상태**: ✅ 완전 구현

---

### 2.2 자원 효율 (Resources) ✅

**입력 정보**:
- 온톨로지 그래프에서 SPARQL 쿼리로 조회
- `required_resources`: COA별 필요한 자원 목록
- `available_resources`: 상황별 가용 자원 목록

**알고리즘**:
```python
# core_pipeline/reasoning_engine.py
def _extract_resource_availability(self, context: Dict) -> float:
    # COA별 필요한 자원 조회
    required = ontology_manager.execute_template_query(
        "find_required_resources",
        coa_uri=coa_uri
    )
    # 상황별 가용 자원 조회
    available = ontology_manager.execute_template_query(
        "find_available_resources",
        situation_uri=situation_id
    )
    # 자원 매칭률 계산
    if required and available:
        matched = set(required) & set(available)
        match_ratio = len(matched) / len(required)
        return match_ratio
```

**구현 상태**: ✅ 완전 구현 (온톨로지 그래프에서 추출)

---

### 2.3 자산 능력 (Assets) ✅

**입력 정보**:
- `defense_assets`: `situation_info.get('가용장비', [])`
- 자산별 화력(firepower), 사기(morale) 정보

**알고리즘**:
```python
# core_pipeline/coa_scorer.py
def _calculate_asset_score(self, context: Dict) -> float:
    defense_assets = context.get('defense_assets', [])
    if defense_assets:
        firepowers = [asset.get('firepower', 0) for asset in defense_assets]
        if firepowers:
            avg_firepower = sum(firepowers) / len(firepowers)
            asset_capability = avg_firepower / 100.0  # 0-1 정규화
            return min(1.0, max(0.0, asset_capability))
```

**구현 상태**: ✅ 완전 구현

---

### 2.4 환경 적합 (Environment) ✅

**입력 정보**:
- 온톨로지 그래프에서 SPARQL 쿼리로 조회
- 위협상황의 기상상황 (`occursInEnvironment`)
- COA의 환경 호환성 (`compatibleWith`)

**알고리즘**:
```python
# core_pipeline/reasoning_engine.py
def _extract_environment_fit(self, context: Dict) -> float:
    # 위협상황의 기상상황 조회
    weather = ontology_manager.query(
        f"SELECT ?weather WHERE {{ <{situation_id}> ns1:occursInEnvironment ?weather }}"
    )
    # COA의 환경 호환성 조회
    compatibility = ontology_manager.query(
        f"SELECT ?env WHERE {{ <{coa_uri}> ns1:compatibleWith ?env }}"
    )
    # 호환성 점수 계산
    if weather and compatibility:
        # 매칭된 환경 수에 비례하여 점수 계산
        ...
```

**구현 상태**: ✅ 완전 구현 (온톨로지 그래프에서 추출)

---

### 2.5 과거 사례 (Historical) ✅

**입력 정보**:
- `rag_results`: RAG 검색 결과 (유사 상황 검색)

**알고리즘**:
```python
# core_pipeline/coa_scorer.py
def _calculate_historical_score(self, context: Dict) -> float:
    rag_results = context.get('rag_results', [])
    if rag_results:
        # 성공 사례 비율 계산
        success_keywords = ['성공', '효과적', '승리', '완료', '달성']
        success_count = 0
        for result in rag_results:
            text = result.get('text', '') if isinstance(result, dict) else str(result)
            if any(keyword in text for keyword in success_keywords):
                success_count += 1
        if len(rag_results) > 0:
            historical_success = success_count / len(rag_results)
            return min(1.0, max(0.0, historical_success))
```

**구현 상태**: ✅ 완전 구현 (키워드 매칭 방식)

---

### 2.6 연계 작전 (Chain) ✅

**입력 정보**:
- 온톨로지 그래프에서 관계 체인 탐색
- `chain_info`: 위협과 방책 간의 관계 체인

**알고리즘**:
```python
# agents/defense_coa_agent/logic_defense_enhanced.py
def _calculate_chain_info(self, strategy: Dict, situation_info: Dict) -> Dict:
    graph = self.core.ontology_manager.graph
    threat_uri = ...
    
    # COA 체인 탐색
    chains = self.core.relationship_chain.find_coa_chains(
        graph,
        str(threat_uri)
    )
    
    if chains:
        chain_summary = self.core.relationship_chain.get_chain_summary(chains)
        return {
            "chains": chains[:5],
            "summary": chain_summary
        }
```

**구현 상태**: ✅ 완전 구현 (그래프 기반 체인 탐색)

### 2.7 임무 부합성 (Mission Alignment) ✅

**입력 정보**:
- `mission_type`: 현 임무 유형 (예: "공격", "방어")
- `coa_type`: 방책 유형

**알고리즘**:
```python
# core_pipeline/coa_scorer.py
def _calculate_mission_alignment_score(self, context: Dict) -> float:
    mission_type = context.get('mission_type')
    coa_type = context.get('coa_type')
    # 사전 정의된 매트릭스 참조
    alignment_score = MISSION_COA_ALIGNMENT[mission_type][coa_type]
    return alignment_score
```

**구현 상태**: ✅ 완전 구현

---

## 3. 가중치 시스템

### 3.1 기본 가중치

| 요소 | 가중치 | 설명 |
|------|--------|------|
| 위협 대응 | 0.25 | 가장 중요 |
| 자원 효율 | 0.20 | 자원 활용도 |
| 자산 능력 | 0.15 | 전투력 반영 |
| 환경 적합 | 0.15 | 작전 환경 부합도 |
| 과거 사례 | 0.15 | 역사적 성공률 |
| 연계 작전 | 0.10 | 작전 연계성 |

### 3.2 가중치 설정

**설정 파일**: `data_lake/평가기준_가중치.xlsx`

**동적 조정**: 상황에 따라 가중치를 조정할 수 있음

---

## 4. 팔란티어 모드

### 4.1 특징

- **독립적 컨텍스트**: 각 방책별로 가상의 실행 환경(Context)을 구성
- **개별 시뮬레이션**: 각 컨텍스트에서 6가지 요소별 점수 계산
- **보정 (Adjustment)**: 특수 조건에 따른 가점/감점 적용

### 4.2 처리 과정

```python
# agents/defense_coa_agent/logic_defense_enhanced.py
def _score_with_palantir_mode(self, strategies, situation_info, ...):
    for strategy in strategies:
        # 1. 컨텍스트 생성
        context = {
            "threat_level": threat_level,
            "resource_availability": resource_availability,  # 온톨로지에서 추출
            "environment_fit": environment_fit,  # 온톨로지에서 추출
            "defense_assets": situation_info.get('가용장비', []),
            "rag_results": situation_analysis.get("rag_results", []),
            "chain_info": chain_info
        }
        
        # 2. 점수 계산
        score_result = scorer.calculate_score(context)
        
        # 3. 보정 적용
        if threat_level >= 0.9:
            score_result['total_score'] += 0.1  # 가점
```

---

## 5. 점수 계산 공식

### 5.1 기본 공식 (MAUT)

$$ Total Score = \sum_{i=1}^{6} (Score_i \times Weight_i) $$

### 5.2 팔란티어 모드 공식

$$ Total Score = \sum_{i=1}^{6} (Score_i \times Weight_i) + Adjustment $$

**Adjustment**: 특수 조건에 따른 가점/감점

---

## 6. 구현 상태 요약

| 요소 | 입력 정보 | 알고리즘 | 구현 상태 |
|------|-----------|----------|-----------|
| 위협 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |
| 자원 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |
| 자산 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |
| 환경 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |
| 과거 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |
| 체인 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |
| 임무 | ✅ 제공됨 | ✅ 구현됨 | ✅ 완전 구현 |

**전체 구현률**: **100% (7/7)** ✅

---

## 7. 주요 코드 위치

- **점수 계산**: `core_pipeline/coa_scorer.py`
- **요소 추출**: `core_pipeline/reasoning_engine.py`
- **체인 탐색**: `core_pipeline/relationship_chain.py`
- **Agent 로직**: `agents/defense_coa_agent/logic_defense_enhanced.py`

---

## 8. 참고 자료

- `docs/방책추천_시스템.md`: 방책 추천 시스템 전체 설명
- `core_pipeline/coa_scorer.py`: 점수 계산 구현 코드
- `data_lake/평가기준_가중치.xlsx`: 가중치 설정 파일

---

**작성일**: 2025년 12월  
**최종 업데이트**: 2025-12-18  
**버전**: 2.0 (통합 버전)

